# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import plpy
import os

import keras
from keras import backend as K
from keras.layers import *
from keras.models import *
from keras.optimizers import *
import numpy as np

from utilities.model_arch_info import get_input_shape
from utilities.validate_args import input_tbl_valid
from utilities.validate_args import output_tbl_valid

from madlib_keras_helper import convert_string_of_args_to_dict

def predict(schema_madlib, model_table, test_table, id_col, model_arch_table,
            model_arch_id, independent_varname, compile_params, output_table,
            **kwargs):
    module_name = 'madlib_keras_predict'
    input_tbl_valid(test_table, module_name)
    input_tbl_valid(model_arch_table, module_name)
    output_tbl_valid(output_table, module_name)

    # _validate_input_args(test_table, model_arch_table, output_table)

    model_data_query = "SELECT model_data from {0}".format(model_table)
    model_data = plpy.execute(model_data_query)[0]['model_data']

    model_arch_query = "SELECT model_arch, model_weights FROM {0} " \
                       "WHERE id = {1}".format(model_arch_table, model_arch_id)
    query_result = plpy.execute(model_arch_query)
    if not  query_result or len(query_result) == 0:
        plpy.error("no model arch found in table {0} with id {1}".format(model_arch_table, model_arch_id))
    query_result = query_result[0]
    model_arch = query_result['model_arch']
    input_shape = get_input_shape(model_arch)
    compile_params = "$madlib$" + compile_params + "$madlib$"
    predict_query = plpy.prepare("""create table {output_table} as
        select {id_col}, (madlib.internal_keras_predict({independent_varname},
                                             $MAD${model_arch}$MAD$,
                                             $1,ARRAY{input_shape},
                                             {compile_params}))[1] as prediction
        from {test_table}""".format(**locals()), ["bytea"])
    plpy.execute(predict_query, [model_data])

def internal_keras_predict(x_test, model_arch, model_data, input_shape, compile_params):
    model = model_from_json(model_arch)
    compile_params = convert_string_of_args_to_dict(compile_params)
    device_name = '/cpu:0'
    os.environ["CUDA_VISIBLE_DEVICES"] = '-1'

    with K.tf.device(device_name):
        model.compile(**compile_params)

    model_shapes = []
    for weight_arr in model.get_weights():
        model_shapes.append(weight_arr.shape)
    _,_,_, model_weights = deserialize_weights(model_data, model_shapes)
    model.set_weights(model_weights)
    x_test = np.array(x_test).reshape(1, *input_shape)
    x_test /= 255
    res = model.predict_classes(x_test)
    return res
